#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
#+TITLE: leetcode notes
#+KEYWORDS: algorithm


** two sum
#+BEGIN_SRC go
  package main
  import (
          "fmt"
  )

  func twoSum(nums []int, target int) []int {
          m := map[int]int{}
          for i := range nums {
                  ind, ok := m[target-nums[i]]
                  if ok {
                          return []int{ind, i}
                  }
                  m[nums[i]] = i
          }
          return nil
  }

  func main() {
          fmt.Printf("%+v\n", twoSum([]int{2, 7, 11, 15}, 9)) // output for debug

  }
#+END_SRC

#+RESULTS:
: [0 1]

** add two numbers
#+BEGIN_SRC go
package main
import (
	"fmt"
)

/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
type ListNode struct {
	Val  int
	Next *ListNode
}

func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
	r := ListNode{}
	tmpr := &r
	var last *ListNode
	carry := false
	for {
		rr := 0
		if carry {
			rr += 1
			carry = false
		}
		if l1 != nil {
			rr += l1.Val
			l1 = l1.Next
		}
		if l2 != nil {
			rr += l2.Val
			l2 = l2.Next
		}
		if rr > 9 {
			carry = true
			rr -= 10
		}
		if rr == 0 && !carry && l1 == nil && l2 == nil {
			if last != nil {
				last.Next = nil
			}
			return &r
		}
		tmpr.Val = rr
		tmpr.Next = &ListNode{}
		tmpr.Next.Next = nil
		last = tmpr
		tmpr = tmpr.Next
	}
	return nil
}

func main() {
	l1 := &ListNode{Val: 2, Next: &ListNode{Val: 4, Next: &ListNode{Val: 3, Next: nil}}}
	l2 := &ListNode{Val: 5, Next: &ListNode{Val: 6, Next: &ListNode{Val: 4, Next: nil}}}
	r := addTwoNumbers(l1, l2)
	fmt.Printf("%+v\n", r)                // output for debug
	fmt.Printf("%+v\n", r.Next)           // output for debug
	fmt.Printf("%+v\n", r.Next.Next)      // output for debug
	fmt.Printf("%+v\n", r.Next.Next.Next) // output for debug
}
#+END_SRC

#+RESULTS:
: &{Val:7 Next:0xc0000101f0}
: &{Val:0 Next:0xc000010200}
: &{Val:8 Next:<nil>}
: <nil>

** Longest Substring Without Repeating Characters
#+BEGIN_SRC go
  package main

  import (
          "fmt"
  )

  func lengthOfLongestSubstring(s string) int {
          m := map[byte]int{}
          i, j := 0, 0
          max := 0
          for ; j < len(s); j++ {
                  if ind, ok := m[s[j]]; ok && ind >= i {
                          i = ind + 1
                  }
                  m[s[j]] = j
                  if max < j-i+1 {
                          max = j - i + 1
                  }
          }
          return max
  }

  func main() {
          fmt.Printf("%+v\n", lengthOfLongestSubstring("abcabcbb")) // output for debug
          fmt.Printf("%+v\n", lengthOfLongestSubstring("bbbbbbbb")) // output for debug
          fmt.Printf("%+v\n", lengthOfLongestSubstring("pwwkew"))   // output for debug
          fmt.Printf("%+v\n", lengthOfLongestSubstring("abba"))     // output for debug
  }


#+END_SRC

#+RESULTS:
: 3
: 1
: 3
: 2

** Median of Two Sorted Arrays
#+BEGIN_SRC go
  package main

  import (
          "fmt"
  )

  func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
          m := len(nums1)
          n := len(nums2)
          if m > n {
                  n, m = m, n
                  nums1, nums2 = nums2, nums1
          }
          imin, imax := 0, m
          for imin <= imax {
                  i := (imin + imax) / 2
                  j := (m+n)/2 - i
                  if i > 0 && nums1[i-1] > nums2[j] {
                          imax = i - 1
                  } else if i < imax && nums2[j-1] > nums1[i] {
                          imin = i + 1
                  } else {
                          maxleft := 0
                          minright := 0
                          if i == m {
                                  minright = nums2[j]
                          } else if j == n {
                                  minright = nums1[i]
                          } else {
                                  if nums1[i] < nums2[j] {
                                          minright = nums1[i]
                                  } else {
                                          minright = nums2[j]
                                  }
                          }
                          if (m+n)%2 == 1 {
                                  return float64(minright)
                          }
                          if i < 1 {
                                  maxleft = nums2[j-1]
                          } else if j < 1 {
                                  maxleft = nums1[i-1]
                          } else {
                                  if nums1[i-1] > nums2[j-1] {
                                          maxleft = nums1[i-1]
                                  } else {
                                          maxleft = nums2[j-1]
                                  }
                          }

                          return float64(minright+maxleft) / 2.0
                  }
          }

          return 0.0
  }

  func main() {
          fmt.Printf("%+v\n", findMedianSortedArrays([]int{1, 2, 3, 5, 6, 7, 8}, []int{3, 4})) // output for debug
  }

#+END_SRC

#+RESULTS:
: 4

** Longest Palindromic Substring
#+BEGIN_SRC go
  package main

  import (
          "fmt"
  )

  func longestPalindrome(s string) string {
          if len(s) == 0 {
                  return ""
          }
          m := [1000][1000]bool{}
          for i := 0; i < len(s); i++ {
                  m[i][i] = true
          }
          for l := 1; l < len(s); l++ {
                  for i := 0; i+l < len(s); i++ {

                          if i+1 <= i+l-1 && m[i+1][i+l-1] && s[i] == s[i+l] {
                                  m[i][i+l] = true
                          } else if l == 1 && s[i] == s[i+l] {
                                  m[i][i+l] = true
                          }
                  }
          }

          max := 1
          maxs := string([]byte(s)[0:1])
          for i := 0; i < len(s); i++ {
                  for j := i; j < len(s); j++ {
                          if m[i][j] && j-i+1 > max {
                                  max = j - i + 1
                                  maxs = string([]byte(s)[i : j+1])
                          }
                  }
          }
          return maxs
  }

  func main() {
          fmt.Printf("%+v\n", longestPalindrome("babad")) // output for debug
          fmt.Printf("%+v\n", longestPalindrome("cbbd"))  // output for debug
          fmt.Printf("%+v\n", longestPalindrome(""))      // output for debug
  }
#+END_SRC

** ZigZag Conversion
#+BEGIN_SRC go
func convert(s string, numRows int) string {
	if numRows == 1 {
		return s
	}
	lines := make([][]byte, numRows)
	i := 0
	add := true
	for _, c := range []byte(s) {
		lines[i] = append(lines[i], c)
		if add {
			if i+1 >= numRows {
				i--
				add = false
			} else {
				i++
			}
		} else {
			if i-1 < 0 {
				i++
				add = true
			} else {
				i--
			}
		}
	}

	for i := 1; i < numRows; i++ {
		lines[0] = append(lines[0], lines[i]...)
	}
	return string(lines[0])
}
#+END_SRC
** Reverse Integer
#+BEGIN_SRC go
func reverse(x int) int {
	max := int(math.Pow(2.0, 31.0)) - 1
	min := int(math.Pow(-2.0, 31.0))
	r := 0
	for x != 0 {
		r = 10*r + (x % 10)
		if r > max || r < min {
			return 0
		}
		x /= 10
	}
	return r
}
#+END_SRC
** String to Integer (atoi)
#+BEGIN_SRC go
func myAtoi(str string) int {
	if str == "" {
		return 0
	}
	max := int(math.Pow(2.0, 31)) - 1
	min := int(math.Pow(-2.0, 31))
	i := 0
	for ; i < len(str); i++ {
		if str[i] != ' ' {
			break
		}
	}
	if i == len(str) {
		return 0
	}
	negative := false
	if str[i] >= '0' && str[i] <= '9' {
	} else if str[i] == '+' {
		i++
	} else if str[i] == '-' {
		negative = true
		i++
	} else {
		return 0
	}
	flag := false
	r := 0
	for ; i < len(str); i++ {
		if str[i] >= '0' && str[i] <= '9' {
			flag = true
			r = 10*r + (int(str[i]) - 48)
			if r > max && !negative {
				return max
			} else if (-r) < min && negative {
				return min
			}
		} else if !flag {
			return 0
		} else {
			break
		}
	}
	if negative {
		return (-r)
	}
	return r
}
#+END_SRC

* Bear in mind
  - 检查类似 max, isXXX, flag 的变量是否更新
  - 检查特殊输入,如空字符串
