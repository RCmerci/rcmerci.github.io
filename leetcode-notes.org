#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
#+TITLE: leetcode notes
#+KEYWORDS: algorithm


* two sum
#+BEGIN_SRC go
  package main
  import (
          "fmt"
  )

  func twoSum(nums []int, target int) []int {
          m := map[int]int{}
          for i := range nums {
                  ind, ok := m[target-nums[i]]
                  if ok {
                          return []int{ind, i}
                  }
                  m[nums[i]] = i
          }
          return nil
  }

  func main() {
          fmt.Printf("%+v\n", twoSum([]int{2, 7, 11, 15}, 9)) // output for debug

  }
#+END_SRC

#+RESULTS:
: [0 1]

* add two numbers
#+BEGIN_SRC go
package main
import (
	"fmt"
)

/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
type ListNode struct {
	Val  int
	Next *ListNode
}

func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
	r := ListNode{}
	tmpr := &r
	var last *ListNode
	carry := false
	for {
		rr := 0
		if carry {
			rr += 1
			carry = false
		}
		if l1 != nil {
			rr += l1.Val
			l1 = l1.Next
		}
		if l2 != nil {
			rr += l2.Val
			l2 = l2.Next
		}
		if rr > 9 {
			carry = true
			rr -= 10
		}
		if rr == 0 && !carry && l1 == nil && l2 == nil {
			if last != nil {
				last.Next = nil
			}
			return &r
		}
		tmpr.Val = rr
		tmpr.Next = &ListNode{}
		tmpr.Next.Next = nil
		last = tmpr
		tmpr = tmpr.Next
	}
	return nil
}

func main() {
	l1 := &ListNode{Val: 2, Next: &ListNode{Val: 4, Next: &ListNode{Val: 3, Next: nil}}}
	l2 := &ListNode{Val: 5, Next: &ListNode{Val: 6, Next: &ListNode{Val: 4, Next: nil}}}
	r := addTwoNumbers(l1, l2)
	fmt.Printf("%+v\n", r)                // output for debug
	fmt.Printf("%+v\n", r.Next)           // output for debug
	fmt.Printf("%+v\n", r.Next.Next)      // output for debug
	fmt.Printf("%+v\n", r.Next.Next.Next) // output for debug
}
#+END_SRC

#+RESULTS:
: &{Val:7 Next:0xc0000101f0}
: &{Val:0 Next:0xc000010200}
: &{Val:8 Next:<nil>}
: <nil>

* Longest Substring Without Repeating Characters
#+BEGIN_SRC go
  package main

  import (
          "fmt"
  )

  func lengthOfLongestSubstring(s string) int {
          m := map[byte]int{}
          i, j := 0, 0
          max := 0
          for ; j < len(s); j++ {
                  if ind, ok := m[s[j]]; ok && ind >= i {
                          i = ind + 1
                  }
                  m[s[j]] = j
                  if max < j-i+1 {
                          max = j - i + 1
                  }
          }
          return max
  }

  func main() {
          fmt.Printf("%+v\n", lengthOfLongestSubstring("abcabcbb")) // output for debug
          fmt.Printf("%+v\n", lengthOfLongestSubstring("bbbbbbbb")) // output for debug
          fmt.Printf("%+v\n", lengthOfLongestSubstring("pwwkew"))   // output for debug
          fmt.Printf("%+v\n", lengthOfLongestSubstring("abba"))     // output for debug
  }


#+END_SRC

#+RESULTS:
: 3
: 1
: 3
: 2

* Median of Two Sorted Arrays
#+BEGIN_SRC go
  package main

  import (
          "fmt"
  )

  func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
          m := len(nums1)
          n := len(nums2)
          if m > n {
                  n, m = m, n
                  nums1, nums2 = nums2, nums1
          }
          imin, imax := 0, m
          for imin <= imax {
                  i := (imin + imax) / 2
                  j := (m+n)/2 - i
                  if i > 0 && nums1[i-1] > nums2[j] {
                          imax = i - 1
                  } else if i < imax && nums2[j-1] > nums1[i] {
                          imin = i + 1
                  } else {
                          maxleft := 0
                          minright := 0
                          if i == m {
                                  minright = nums2[j]
                          } else if j == n {
                                  minright = nums1[i]
                          } else {
                                  if nums1[i] < nums2[j] {
                                          minright = nums1[i]
                                  } else {
                                          minright = nums2[j]
                                  }
                          }
                          if (m+n)%2 == 1 {
                                  return float64(minright)
                          }
                          if i < 1 {
                                  maxleft = nums2[j-1]
                          } else if j < 1 {
                                  maxleft = nums1[i-1]
                          } else {
                                  if nums1[i-1] > nums2[j-1] {
                                          maxleft = nums1[i-1]
                                  } else {
                                          maxleft = nums2[j-1]
                                  }
                          }

                          return float64(minright+maxleft) / 2.0
                  }
          }

          return 0.0
  }

  func main() {
          fmt.Printf("%+v\n", findMedianSortedArrays([]int{1, 2, 3, 5, 6, 7, 8}, []int{3, 4})) // output for debug
  }

#+END_SRC

#+RESULTS:
: 4

