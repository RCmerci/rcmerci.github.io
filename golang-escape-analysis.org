#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
#+TITLE: Golang escape analysis
#+KEYWORDS: golang
#+OPTIONS: toc:nil num:3 H:4 ^:nil pri:t


#+BEGIN_abstract
This article introduces the principle and general implementation of
golang's escape analysis.
#+END_abstract
#+TOC: headlines 2




** TODO Some examples
*** example 1
#+BEGIN_SRC go
  // go tool compile -m -m -m -m -l main.go
  package main

  func f1(a int) (b *int) {
	  b = &a
	  return
  }
#+END_SRC    
compiler output:
#+BEGIN_SRC 
escAnalyze [0xc000384000]
.   DCLFUNC l(3) esc(no) tc(1) FUNC-func(int) *int
.   DCLFUNC-body
.   .   AS l(4) tc(1)
.   .   .   NAME-main.b a(true) g(1) l(3) x(0) class(PPARAMOUT) tc(1) assigned PTR-*int
.   .   .   ADDR l(4) tc(1) PTR-*int
.   .   .   .   NAME-main.a a(true) g(2) l(3) x(0) class(PPARAM) tc(1) addrtaken used int

.   .   RETURN l(5) tc(1)
main.go:4:4:[1] f1 esc: b
main.go:4:6:[1] f1 esc: a
main.go:4:6:[1] f1 esc: &a
main.go:4:4:[1] f1 esc: b = &a
main.go:4:4:[1] f1 escassign: b( a(true) g(1) l(3) x(0) class(PPARAMOUT) tc(1) assigned)[NAME] = &a( l(4) esc(no) ld(1) tc(1))[&]
main.go:4:6::flows:: b <- &a
main.go:5:2:[1] f1 esc: return 

escflood:0: dst b scope:f1[0]
escwalk: level:{0 0} depth:0  op=& &a( l(4) esc(no) ld(1) tc(1)) scope:f1[1] extraloopdepth=-1
main.go:4:6: &a escapes to heap, level={0 0}, dst=b dst.eld=0, src.eld=1
main.go:3:9: moved to heap: a
escwalk: level:{-1 -1} depth:1 	 op=NAME a( a(true) g(2) l(3) x(0) class(PAUTOHEAP) esc(h) ld(1) tc(1) addrtaken used) scope:f1[1] extraloopdepth=1
#+END_SRC
- '&a' escapes to heap
- 'a' moved to heap
*** TODO example 2
#+BEGIN_SRC  go
  // go tool compile -m -m -m -m -l main.go
  package main

  func f2(a *int) *int {
	  return a
  }
#+END_SRC
#+BEGIN_SRC 
escAnalyze [0xc0000d82c0]
.   DCLFUNC l(19) esc(no) tc(1) FUNC-func(*int) *int
.   DCLFUNC-body
.   .   RETURN l(20) tc(1)
.   .   RETURN-list
.   .   .   NAME-main.a a(true) g(2) l(19) x(0) class(PPARAM) tc(1) used PTR-*int
main.go:20:2:[1] f2 esc: a
main.go:20:2:[1] f2 esc: return a
main.go:20:2:[1] f2 escassign: ~r1( a(true) g(1) l(19) x(0) class(PPARAMOUT))[NAME] = a( a(true) g(2) l(19) x(0) class(PPARAM) esc(no) ld(1) tc(1) used)[NAME]
main.go:20:2::flows:: ~r1 <- a

escflood:0: dst ~r1 scope:f2[0]
escwalk: level:{0 0} depth:0  op=NAME a( a(true) g(2) l(19) x(0) class(PPARAM) esc(no) ld(1) tc(1) used) scope:f2[1] extraloopdepth=-1
main.go:19:9: leaking param: a to result ~r1 level={0 0}
#+END_SRC


*** example 3
#+BEGIN_SRC go
  // go tool compile -m -m -m -l main.go
  package main
  type A interface {
	  AA(a int)
  }

  func f2(a A) {
	  b := 1
	  a.AA(b)
  }
#+END_SRC
#+BEGIN_SRC 
main.go:8:2:[1] f2 esc: b
main.go:8:2:[1] f2 esc: var b int
main.go:8:4:[1] f2 esc: b
main.go:8:7:[1] f2 esc: 1
main.go:8:4:[1] f2 esc: b := 1
main.go:8:4:[1] f2 escassign: b( a(true) g(2) l(8) x(0) class(PAUTO) ld(1) tc(1) used)[NAME] = 1( l(8) tc(1))[LITERAL]
main.go:9:3:[1] f2 esc: a
main.go:9:3:[1] f2 esc: a.AA
main.go:9:6:[1] f2 esc: b
main.go:9:6:[1] f2 esc: a.AA(b)
main.go:9:6:[1] f2 escassign: .sink( x(0) class(PEXTERN) ld(-1))[NAME] = b( a(true) g(2) l(8) x(0) class(PAUTO) ld(1) tc(1) used)[NAME]
main.go:9:6:[1] f2 escassign: .sink( x(0) class(PEXTERN) ld(-1))[NAME] = a( a(true) g(1) l(7) x(0) class(PPARAM) esc(no) ld(1) tc(1) used)[NAME]

escflood:0: dst .sink scope:<S>[-1]
escwalk: level:{0 0} depth:0  op=NAME a( a(true) g(1) l(7) x(0) class(PPARAM) esc(no) ld(1) tc(1) used) scope:f2[1] extraloopdepth=-1
main.go:7:9: leaking param: a level={0 0} dst.eld=-1 src.eld=1 dst=.sink
<autogenerated>:1:[1] A.AA esc: .this
<autogenerated>:1:[1] A.AA esc: .this.AA
<autogenerated>:1:[1] A.AA esc: a
<autogenerated>:1:[1] A.AA esc: .this.AA(a)
<autogenerated>:1:[1] A.AA escassign: .sink( x(0) class(PEXTERN) ld(-1))[NAME] = a( a(true) g(2) l(4) x(0) class(PPARAM) ld(1) tc(1) used)[NAME]
<autogenerated>:1:[1] A.AA escassign: .sink( x(0) class(PEXTERN) ld(-1))[NAME] = .this( a(true) g(1) l(1) x(0) class(PPARAM) esc(no) ld(1) tc(1) used)[NAME]

escflood:0: dst .sink scope:A.AA[-1]
escwalk: level:{0 0} depth:0  op=NAME .this( a(true) g(1) l(1) x(0) class(PPARAM) esc(no) ld(1) tc(1) used) scope:A.AA[1] extraloopdepth=-1
<autogenerated>:1: leaking param: .this level={0 0} dst.eld=-1 src.eld=1 dst=.sink
#+END_SRC
** high level steps of escape analysis
   Analyze all defined functions from the bottom up(=visitBottomUp=),
   analyze a set of functions (recursively with each other) or a
   function each time using =escAnalyze=.
   
   The general flow of =escAnalyze=:
   - Construct all flows of src -> dst (=escfunc=)
   - Traverse all dsts, mark on =Node= that meets the escape condition (=escflood=)

** visitBottomUp
   The entry in =escape analysis= is the =escapes= function.
#+BEGIN_SRC go
func escapes(all []*Node) {
	visitBottomUp(all, escAnalyze)
}
func escAnalyze(all []*Node, recursive bool) {
        //...
}
func visitBottomUp(list []*Node, analyze func(list []*Node, recursive bool)) {
        // ...
	for _, n := range list {
		if n.Op == ODCLFUNC && !n.Func.IsHiddenClosure() {
			v.visit(n)
		}
	}
}
#+END_SRC   
On the whole, =[]*Node= can be seen as a list of trees, also as a graph, because
some subtrees are connected to each other.

As you can see from the name of =visitBottomUp=, it will traverse from bottom to
top, and its argument =analyze='s first argument =list= is =[]*Node=, its
content is a list of functions, each function will only call other functions in
the list or functions that have been passed in previous invocations of =analyze=

Said in the previous paragraph, the function in =list= will only call the
functions in =list=.  
This includes 2 cases:
- Several functions that are called recursively to each other
- Single function



** draft notes
   - What does 'loopdepth' do?
     
   - what is sink node?

   - what's level.copy for?

** references
- https://web.archive.org/web/20170930011137/http://blog.rocana.com/golang-escape-analysis
